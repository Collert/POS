{% load static %}
{% load i18n %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="{% static 'online_store/layers.css' %}" rel="stylesheet">
    <link href="{% static 'online_store/project-styles.css' %}" rel="stylesheet">
    <link rel="manifest" href="{% static 'online_store/manifest.json' %}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Display:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <title>Sunflower Hearth</title>
    <link rel="icon" type="image/x-icon" href="{% static 'online_store/icon.ico' %}">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        .material-symbols-outlined {
          font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 48
        }
    </style>
    <script>
        function urlB64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');

            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);

            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        function checkNotificationPermission() {
            // Check if the browser supports notifications
            if (!('Notification' in window)) {
                console.error('This browser does not support notifications.');
                return undefined;
            }
    
            return Notification.permission === 'granted'
        }

        function askNotificationPermission(swReg) {
            // Request permission from the user
            return Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('Notification permission granted.');
                    // You can now show notifications
                    return fetch('{% url "deliveries_vapid_public_key" %}')
                    .then(response => response.json())
                    .then(data => {
                        const applicationServerKey = urlB64ToUint8Array(data.vapidPublicKey);
                        swReg.pushManager.subscribe({
                            userVisibleOnly: true,
                            applicationServerKey: applicationServerKey
                        })
                        .then(function(subscription) {
                            console.log('User is subscribed:', subscription);
        
                            // Send the subscription to server to save it
                            fetch("{% url 'deliveries_save_subscription' %}", {
                            method: 'POST',
                            body: JSON.stringify(subscription),
                            headers: {
                                'Content-Type': 'application/json'
                            }
                            });
                        })
                        .catch(function(err) {
                            console.log('Failed to subscribe the user: ', err);
                        });
                    });
                } else if (permission === 'denied') {
                    console.log('Notification permission denied.');
                    // alert("Please enable notifications to use this app")
                } else {
                    console.log('Notification permission dismissed.');
                    // alert("Please enable notifications to use this app")
                }
            });
        }
    </script>
    {% if menu %}
    <script>
        function getContrastingColor(hex) {
            // Ensure the hex color is valid and remove any '#' character
            hex = hex.replace('#', '');

            // Check if the hex color is short form (e.g., 'FFF') and convert it to long form if necessary
            if (hex.length === 3) {
                hex = hex.split('').map(function (hexChar) {
                    return hexChar + hexChar;
                }).join('');
            }

            // Convert hex to RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            // Invert each color component by subtracting it from 255
            const rInv = 255 - r;
            const gInv = 255 - g;
            const bInv = 255 - b;

            // Convert the inverted RGB values back to hex
            const rHex = rInv.toString(16).padStart(2, '0');
            const gHex = gInv.toString(16).padStart(2, '0');
            const bHex = bInv.toString(16).padStart(2, '0');

            // Return the formatted hex color
            return `#${rHex}${gHex}${bHex}`;
        }

        const originalColor = '{{menu.menu.background_color}}';
        const contrastingColor = getContrastingColor(originalColor);
        document.documentElement.style.setProperty('--primary-contrast', contrastingColor);
    </script>
    {% endif %}
    <style>
        :root {
            --primary-background: {{menu.menu.background_color}};
            --accent-1: {{menu.menu.accent_1}};
            --accent-2: {{menu.menu.accent_2}};
            --accent-3: {{menu.menu.accent_3}};
        }
    </style>    
</head>
<body>
    {% csrf_token %}
    <header id="landscape">
        <div id="header-left">
            <a href="{% url 'store_home' %}">
                <img id="logo" src="{% static 'online_store/logo.png' %}" alt="logo">
            </a>
            <nav id="nav-1">
                <a href="{% url 'menu' %}">{% trans "Menu" %}</a>
                <a href="{% url 'get-card' %}">{% trans "Gift Cards" %}</a>
                <!-- <a href="{% url 'menu' %}">Impact</a> -->
            </nav>
        </div>
        <nav id="nav-2">
            <a class="history-button" href="{% url 'order_history' %}"><dfn title="Order history"><span class="material-symbols-outlined">history</span></dfn></a>
            {% if request.user %}
            <a href="{% url 'profile' %}"><dfn title="Account"><span class="material-symbols-outlined">person</span></dfn></a>
            {% else %}
            <a href="{% url 'login' %}" class="button">{% trans "Log In" %}</a>
            {% endif %}
            <button class="button cart-button">
                <span class="material-symbols-outlined">shopping_bag</span>
                <span hidden class="cart-count">1</span>
            </button>
        </nav>
    </header>
    <header id="portrait">
        <a href=""><span class="material-symbols-outlined">redeem</span></a>
        <img id="logo" src="{% static 'online_store/logo.png' %}" alt="logo">
        <a class="history-button" href="{% url 'order_history' %}"><span class="material-symbols-outlined">history</span></a>
    </header>
    <main id="{{route}}">{% block body %}{% endblock %}</main>
    <footer>
        <div id="footer-cart">
            <span class="subtotal-wrapper">$<span class="subtotal"></span></span>
            <div id="cart-container">
                <span hidden class="cart-count"></span>
                <button class="cart-button">
                    <span class="material-symbols-outlined">shopping_bag</span>
                </button>
            </div>
        </div>
        <nav>
            <a href="{% url 'store_home' %}"><span class="material-symbols-outlined">home</span><span>{% trans "Home" %}</span></a>
            <a href="{% url 'menu' %}"><span class="material-symbols-outlined">menu_book</span><span>{% trans "Menu" %}</span></a>
            <a href="{% url 'get-card' %}"><span class="material-symbols-outlined">add_card</span><span>{% trans "Gift cards" %}</span></a>
            <a href="{% url 'profile' %}"><span class="material-symbols-outlined">person</span><span>{% trans "Account" %}</span></a>
        </nav>
    </footer>
    <dialog id="cart">
        <div>
            <header>
                <h1>Cart</h1>
                <button class="icon close-button" id="close-cart"><span class="material-symbols-outlined">close</span></button>
            </header>
            <div id="cart-items">
                <div hidden class="cart-item">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/No-Image-Placeholder.svg/1665px-No-Image-Placeholder.svg.png">
                    <div>
                        <h2>Title</h2>
                        <small hidden></small>
                    </div>
                    <span class="price">$25</span>
                    <button><span class="material-symbols-outlined">delete</span></button>
                </div>
            </div>
            <footer>
                <span id="subtotal-wrapper">{% trans "Subtotal:" %} $<span id="subtotal">0</span></span>
                <button disabled id="checkout">
                    <span class="material-symbols-outlined">shopping_cart_checkout</span>
                    <span>{% trans "Finalize" %}</span>
                </button>
            </footer>
        </div>
    </dialog>
    <dialog id="finalize-dialog" class="full">
        <form method="post" id="finalize-form" class="attach-card-payment" action="{% url 'submit_order' %}">
            {% csrf_token %}
            <header>
                <h1>{% trans "Finalize cart" %}</h1>
                <button class="icon close-button" type="button"><span class="material-symbols-outlined">close</span></button>
            </header>
            <div class="pick-up" id="finalize-menu">
                <input hidden name="cart-string" id="cart-string" type="text">
                <input hidden name="transaction-amount" id="transaction-amount" type="text">
                <h2>{% trans "Who?" %}</h2>
                <div id="who">
                    <div>
                        <label for="name-input">{% trans "Name" %}</label>
                        <input required id="name-input" name="name" type="text">
                    </div>
                    <div>
                        <label for="phone-number">{% trans "Phone number" %}</label>
                        <input required id="phone-number" name="phone" type="tel">
                    </div>
                </div>
                <span class="line-divider"></span>
                <h2>{% trans "Where?" %}</h2>
                <div id="delivery-pickup-toggle">
                    <input required type="radio" id="delivery-pickup-toggle1" name="delivery-pickup-toggle" checked value="pick-up" />
                    <label for="delivery-pickup-toggle1" class="delivery-pickup-toggle-label"><span class="material-symbols-outlined">person_pin_circle</span>{% blocktrans %}Pick up at<br>the restaurant{% endblocktrans %}</label>
        
                    <input required type="radio" id="delivery-pickup-toggle2" name="delivery-pickup-toggle" value="delivery" />
                    <label for="delivery-pickup-toggle2" class="delivery-pickup-toggle-label"><span class="material-symbols-outlined">local_shipping</span>{% blocktrans %}Order<br>delivery{% endblocktrans %}</label>
                </div>
                <strong class="pick-up-item">{% trans "Address" %}</strong>
                <p class="pick-up-item">501 4th Ave, New Westminster, BC V3L 1P3</p>
                <div class="delivery-item container">
                    <div>
                        <label class="delivery-item" for="delivery-address-2">{% trans "Address 1" %}</label>
                        <input data-required="true" class="delivery-item delivery-address-field" id="delivery-address-1" name="delivery-address-1" type="text">
                    </div>
                    <div>
                        <label class="delivery-item" for="delivery-address-2">{% trans "Address 2" %}</label>
                        <input data-required="true" class="delivery-item delivery-address-field" id="delivery-address-2" name="delivery-address-2" placeholder="{% trans 'Unit # / Apartment #' %}" type="text">
                    </div>
                </div>
                <div class="delivery-item container">
                    <div>
                        <label class="delivery-item" for="delivery-address-3">{% trans "City" %}</label>
                        <input data-required="true" class="delivery-item delivery-address-field" id="delivery-address-3" name="delivery-address-city" type="text">
                    </div>
                    <div>
                        <label class="delivery-item" for="delivery-address-4">{% trans "Province" %}</label>
                        <input disabled value="BC" class="delivery-item delivery-address-field" id="delivery-address-4" name="delivery-address-province" type="text">
                    </div>
                    <div>
                        <label class="delivery-item" for="delivery-address-5">{% trans "Postal code" %}</label>
                        <input data-required="true" class="delivery-item delivery-address-field" id="delivery-address-5" name="delivery-address-postal" type="text">
                    </div>
                </div>
                <strong id="no-cour" hidden class="delivery-item" style="color: var(--error-color);">{% trans "Looks like we don't have any couriers available at the moment. Sorry for inconvenience." %}</strong>
                <strong id="long-delivery" hidden class="delivery-item" style="color: var(--error-color);">It seems like you are pretty far for our fastest courier at the moment. Keep in mind that the food might be off its original temperature when it arrives.</strong>
                <strong id="too-long-delivery" hidden class="delivery-item" style="color: var(--error-color);">It seems like you are too far for our fastest courier at the moment. We are not able to deliver to this address right now. Sorry for inconvenience.</strong>
                <span hidden id="delivery-eta-parrent" class="delivery-item">Estimated delivery time:<br><span id="delivery-eta"></span></span>
                <span class="line-divider"></span>
                <h2>{% trans "When?" %}</h2>
                <input required class="no-style" min="{{business_day_start_time}}" max="{{business_day_end_time}}" type="time" name="time" id="time-field">
                <small>*{% trans "time when we start making the order" %}</small>
                <span class="line-divider"></span>
                <h2>{% trans "How?" %}</h2>
                <div class="pick-up-item" id="here-to-go-toggle">
                    <input type="radio" id="here-to-go-toggle1" class="pick-up-item" name="here-to-go-toggle" checked value="here" />
                    <label for="here-to-go-toggle1" class="here-to-go-toggle-label"><span class="material-symbols-outlined">restaurant</span>{% blocktrans %}Eat at<br>the restaurant{% endblocktrans %}</label>
        
                    <input type="radio" id="here-to-go-toggle2" class="pick-up-item" name="here-to-go-toggle" value="go" />
                    <label for="here-to-go-toggle2" class="here-to-go-toggle-label"><span class="material-symbols-outlined">takeout_dining</span>{% blocktrans %}Pack<br>to-go{% endblocktrans %}</label>
                </div>
                <div class="delivery-item" id="delivery-dropoff-method">
                    <input data-required="true" class="delivery-item" type="radio" id="delivery-dropoff-method1" name="delivery-dropoff-method" value="door" />
                    <label for="delivery-dropoff-method1" class="delivery-dropoff-method-label"><span class="material-symbols-outlined">package</span>{% blocktrans %}Leave at<br>the door{% endblocktrans %}</label>
            
                    <input data-required="true" class="delivery-item" type="radio" id="delivery-dropoff-method2" name="delivery-dropoff-method" value="meet" />
                    <label for="delivery-dropoff-method2" class="delivery-dropoff-method-label"><span class="material-symbols-outlined">meeting_room</span>{% blocktrans %}Meet at<br>the door{% endblocktrans %}</label>
                    
                    <input data-required="true" class="delivery-item" type="radio" id="delivery-dropoff-method3" name="delivery-dropoff-method" value="out" />
                    <label for="delivery-dropoff-method3" class="delivery-dropoff-method-label"><span class="material-symbols-outlined">gate</span>{% blocktrans %}Meet<br>outside{% endblocktrans %}</label>
                </div>
                <p class="delivery-item">{% trans "Delivery instructions (optional)" %}</p>
                <textarea class="delivery-item" name="delivery-instructions" id="delivery-instructions" placeholder="{% trans 'Ring the blue doorbell / meet at the garage door / place the order down and do a lil dance' %}"></textarea>
                <p>{% trans "Special order instructions (optional)" %}</p>
                <textarea name="order-instructions" id="special-instructions" placeholder="{% trans 'Extra sour cream / no onions / extra napkins' %}"></textarea>
                <span class="line-divider"></span>
                <h2>{% trans "Have a gift card?" %}</h2>
                <div id="gift-card-inout-group">
                    <input type="text" maxlength="16" id="card-number-input">
                    <h3 class="error" style="display: none;" id="gift-card-errors"></h3>
                    <button role="button" type="button" id="card-number-lookup-button">{% trans "Look up" %}</button>
                </div>
            </div>
            <span class="line-divider"></span>
            <button type="button" id="proceed-to-checkout">{% trans "Proceed to secure checkout" %}</button>
            <button type="button" id="proceed-to-checkout-free">{% trans "Place order" %}</button>
            <button hidden id="true-submit-button"></button>
            <small>*{% trans "You will only be charged when we confirm your order" %}</small>
        </form>
    </dialog>
    <dialog class="full" id="component-choices-dialog">
        <nav>
            <h2>{% trans "Pick the options" %}</h2>
            <button class="icon close-button"><span class="material-symbols-outlined">close</span></button>
        </nav>
        <iframe style="width: 100%; height: 90%;" frameborder="0"></iframe>
    </dialog>
    <dialog class="full" id="gift-card-dialog">
        <nav>
            <h2 id="transaction-status">{% trans "Gift card" %}</h2>
            <button class="icon close-button"><span class="material-symbols-outlined">close</span></button>
        </nav>
        <div>
            <img id="found-card-image" src="">
            <h2>{% trans "Card #" %}<span id="found-card-number"></span></h2>
            <h4>{% trans "Available balance:" %}</h4>
            <h1>$<span id="found-card-balance"></span></h1>
            <h4 hidden class="card-hold">Held in a different transaction:</h4>
            <h1 hidden class="card-hold">$<span id="found-card-hold"></span></h1>
            <div id="card-actions">
                <form hidden id="card-charge-amount">
                    <input type="number" min="0.01" step=".01" id="card-charge-amount-inp">
                    <button id="card-charge-amount-button">{% trans "Charge card" %}</button>
                </form>
                <button id="card-charge-max">{% trans "Use this card" %}</button>
                <button hidden id="card-reload">{% trans "Reload card" %}</button>
            </div>
        </div>
    </dialog>
    <script type="module" src="{% static 'pos_server/componentChoices.js' %}"></script>
    <script src="{% url 'djangojs' %}"></script>
    <script type="module">
        import { componentChoices } from "/pos_server/static/pos_server/componentChoices.js"
        import { Cart, GiftCardPayment, lookupGiftCard } from "/pos_server/static/pos_server/pos-utils.js"

        const CartDB = {
            save: (cart) => saveCartToIndexedDB(cart),
            load: () => getCartFromIndexedDB(),
        };

        const cartButton = document.querySelectorAll(".cart-button");
        const cartDialog = document.querySelector("#cart");
        const closeButtons = document.querySelectorAll(".close-button");
        const cartCount = document.querySelectorAll(".cart-count");
        const cartItems = document.querySelector("#cart-items");
        const cartItemTemplate = document.querySelector(".cart-item");
        const cartSubtotal = document.querySelectorAll("#subtotal, .subtotal");
        const checkoutBtn = document.querySelector("#checkout");
        const finalizeCheckoutBtn = document.querySelector("#proceed-to-checkout")
        const submitOrderBtn = document.querySelector("#proceed-to-checkout-free")
        const existingCart = await CartDB.load();
        let cart = existingCart ? new Cart(existingCart) : new Cart();
        
        const finalizeDialog = document.querySelector("#finalize-dialog");
        const deliveryPickupToggles = document.querySelectorAll("[name = delivery-pickup-toggle]");
        const finalizeMenu = document.querySelector("#finalize-menu");
        const finalizeForm = document.querySelector("#finalize-form");
        const deliveryAddressFields = document.querySelectorAll(".delivery-address-field");
        const deliveryEta = document.querySelector("#delivery-eta");
        const giftCardDialog = document.querySelector("#gift-card-dialog")
        const giftCardInput = document.querySelector("#card-number-input")
        
        updateCart();
        
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('{% url "service_worker_serve" %}')
                .then((swReg) => {
                    // console.log('Service Worker registered with scope:', swReg.scope);

                    // Check if the service worker is already controlling the page
                    if (!navigator.serviceWorker.controller) {
                        // console.warn('Service Worker is not yet controlling the page.');

                        // Wait for the service worker to be ready
                        navigator.serviceWorker.ready.then(() => {
                            // console.log('Service Worker is ready and controlling the page.');

                            // Reload the page, but only once
                            if (!sessionStorage.getItem('sw-reloaded')) {
                                sessionStorage.setItem('sw-reloaded', 'true');
                                window.location.reload();
                            }
                        });
                    }
                })
                .catch((error) => {
                    console.error('Service Worker registration failed:', error);
                });
        }

        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const currentTime = `${hours}:${minutes}`;

        const choicesChannel = new BroadcastChannel('choices_channel');

        let activeGiftCard;

        document.querySelector("#card-number-lookup-button").addEventListener("click", async () => {
            activeGiftCard = await lookupGiftCard(giftCardInput.value, giftCardDialog)
            giftCardInput.value = ""
        })

        // Adds an event listener to the element with the ID "card-charge-max" that triggers when the element is clicked.
        // The event listener performs the following actions:
        // 1. Calculates the amount to be charged, which is the minimum of the remaining total in the cart and the available balance on the active gift card.
        // 2. Adds a new payment to the cart using the gift card number and the calculated amount.
        // 3. Deducts the charged amount from the available balance of the active gift card.
        // 4. Updates the displayed balance of the gift card.
        // 5. Calls the updateCart() function to refresh the cart's state.
        // 6. Closes any open dialog.
        // 7. Displays an alert indicating the amount redeemed.
        document.querySelector("#card-charge-max").addEventListener("click", async e => {
            const amount = Math.min(cart.remainingTotalNum, activeGiftCard.availableBalance)
            cart.addPayment(new GiftCardPayment(activeGiftCard.number, amount))
            activeGiftCard.availableBalance -= amount
            document.querySelector("#found-card-balance").textContent = activeGiftCard.availableBalance
            updateCart()
            document.querySelector("dialog[open]").close()
            alert(`Redeemed $${amount}`)
        })

        // This script selects all elements with the class "history-button" and appends a query parameter to their href attribute.
        // The query parameter "orders" is set to the value of the "orders" item stored in the browser's local storage, encoded for URL compatibility.
        document.querySelectorAll(".history-button").forEach(element => {
            element.href += `?orders=${encodeURIComponent(window.localStorage.getItem("orders"))}`
        })

        // This script selects all input elements of type 'time' within the finalizeDialog element and updates their 'min' attribute to be either the current time or the time specified in the 'min' attribute, whichever is later.
        // For each time input element, it performs the following actions:
        // 1. Splits the 'min' attribute value (in the format 'HH:MM') into hours and minutes.
        // 2. Creates a Date object using the current year, month, date, and the extracted hours and minutes.
        // 3. Compares the created Date object with the current date and time (now).
        // 4. If the created Date object is earlier than the current date and time, it updates the 'min' attribute of the input element to the current time.
        const timeInputs = finalizeDialog.querySelectorAll("input[type='time']");
        timeInputs.forEach(element => {
            // Crazy aah constructor, all because of timezones grr
            const [hours, minutes] = element.min.split(':').map(Number);
            const inputDateTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
            if (inputDateTime < now) {
                element.min = currentTime;
            }
        })

        // This script adds event listeners to elements with the class 'deliveryPickupToggles'.
        // When the value of these elements changes, it updates the class name of the 'finalizeMenu' element
        // based on the selected value ("delivery" or "pick-up").
        
        // If the selected value is "delivery":
        // - It sets the 'required' attribute to true for all elements with the class 'delivery-item' and a 'data-required' attribute set to "true".
        // - It sets the 'required' attribute to false for all elements with the class 'pick-up-item' and a 'data-required' attribute set to "true".
        
        // If the selected value is "pick-up":
        // - It sets the 'required' attribute to false for all elements with the class 'delivery-item' and a 'data-required' attribute set to "true".
        // - It sets the 'required' attribute to true for all elements with the class 'pick-up-item' and a 'data-required' attribute set to "true".
        deliveryPickupToggles.forEach(toggle => {
            toggle.addEventListener("change", e => {
                finalizeMenu.className = e.currentTarget.value
                if (e.currentTarget.value === "delivery") {
                    document.querySelectorAll('.delivery-item[data-required="true"]').forEach(el => {el.required = true});
                    document.querySelectorAll('.pick-up-item[data-required="true"]').forEach(el => {el.required = false});
                } else if (e.currentTarget.value === "pick-up") {
                    document.querySelectorAll('.delivery-item[data-required="true"]').forEach(el => {el.required = false});
                    document.querySelectorAll('.pick-up-item[data-required="true"]').forEach(el => {el.required = true});
                }
            })
        })

        cartButton.forEach(element => {
            element.addEventListener("click", () => { cartDialog.showModal() })
        })

        closeButtons.forEach(button => {
            button.addEventListener("click", () => { 
                document.querySelector("dialog[open]").close()
            })
        })

        // Function: getDish
        // Description: Retrieves a dish object by its ID from the HTML document.
        // Parameters:
        //     id (string): The ID of the dish to retrieve.
        // Returns:
        //     Object: The dish object corresponding to the provided ID.
        // Details:
        //     - The function searches for an element with the class 'dish-json' and the specified data-id attribute.
        //     - If such an element is found, its innerHTML is parsed as JSON and the first element of the resulting array is returned.
        //     - If no such element is found, the innerHTML of the element with the ID 'item-json' is parsed as JSON and the first element of the resulting array is returned.
        function getDish(id) {
            return JSON.parse(
                    document.querySelector(`.dish-json[data-id="${id}"]`)
                    ? 
                    document.querySelector(`.dish-json[data-id="${id}"]`).innerHTML
                    : 
                    document.querySelector("#item-json").innerHTML
                )[0];
        }

        // This script adds event listeners to all elements with the class "add-to-cart".
        // When an "add-to-cart" button is clicked, it retrieves the dish data using the 
        // `getDish` function, processes the cart item, and adds it to the cart. 
        // Finally, it updates the cart display.
        document.querySelectorAll(".add-to-cart").forEach(but => {
            but.addEventListener("click", e => {
                const dishData = getDish(
                    e.currentTarget.parentElement.querySelector(".dish-json")?.dataset.id
                )
                processCartItem(dishData).forEach(item => {
                    cart.addItem(item, item.noPayment)
                })
                updateCart();
            })
        })
        
        // This script listens for messages on the choicesChannel. 
        // When a message is received, it processes the cart item based on the dish ID and choices provided in the message data. 
        // The processed items are then added to the cart, and the cart is updated. Finally, the choices dialog component is closed.
        choicesChannel.addEventListener("message", e => {
            const newItems = processCartItem(getDish(parseInt(e.data.dishId)), e.data.choices)
            newItems.forEach(item => {
                cart.addItem(item, item.noPayment)
            })
            updateCart();
            document.querySelector("#component-choices-dialog").close()
        })
        
        // Processes a cart item by handling its customizations and choices, and returns a list of processed items.

        // Details:
        // - If the dish has choice components and choices are provided, it processes each choice recursively.
        // - If the dish has choice components but no choices are provided, it calls `componentChoices` to handle the choices.
        // - If the dish is a child of another dish, it sets the parent and determines if the parent is an "only choices" dish.
        // - Adds a `noPayment` flag to the dish if it is a child and the parent is an "only choices" dish.
        // - Constructs a customizations string from the choices and adds it to the dish data.
        function processCartItem(dishData, choices = {}, parent = undefined) {
            let customizationsString = ""
            let parentOnlyChoiceDish = false;
            let final = []
            // console.log(dishData)
            if (dishData.fields.choice_components.length) {
                if (Object.keys(choices).length) {
                        dishData.children = []
                    for (const v of Object.values(choices)) {
                        final = final.concat(processCartItem(getDish(parseInt(v.id)), {}, dishData.id))
                        if (dishData.fields.only_choices) return final
                        dishData.children.push(v)
                        customizationsString += v.title + ", "
                    }
                    customizationsString = customizationsString.slice(0, -2)
                    dishData.customizationsString = customizationsString
                } else {
                    componentChoices(dishData.id)
                    return final
                }
            } else if (parent) {
                dishData.parent = parent
                parentOnlyChoiceDish = getDish(parent).fields.only_choices
            }
            dishData.noPayment = parent && !parentOnlyChoiceDish
            final.push(dishData)
            return final
        }

        checkoutBtn.addEventListener("click", () => {
            if ("{{business_day}}" === "True") {
                cartDialog.close();
                finalizeDialog.showModal();
            } else {
                alert("{% trans 'Sorry, we are closed today. Check the home page for the next date.' %}")
            }
        })
        
        const noCourBadge = document.querySelector("#no-cour");
        const longDeliveryBadge = document.querySelector("#long-delivery");
        const tooLongDeliveryBadge = document.querySelector("#too-long-delivery");

        // This script adds an event listener to each element in the deliveryAddressFields array.
        // When a field loses focus (blur event), it checks if all fields are filled.
        // If any field is empty, it exits the function.
        // If all fields are filled, it enables the finalizeCheckoutBtn and hides all badges.
        // It then constructs a destination string from the field values and calls the checkETA function to get the estimated time of arrival (ETA).
        // If the response status is 404, it shows the noCourBadge and disables the finalizeCheckoutBtn.
        // If the ETA is between 30 and 45 minutes, it shows the longDeliveryBadge.
        // If the ETA is 45 minutes or more, it shows the tooLongDeliveryBadge and disables the finalizeCheckoutBtn.
        // It updates the deliveryEta element with the ETA text and makes its parent element visible.
        deliveryAddressFields.forEach(element => {
            element.addEventListener("blur", async e => {
                for (const field of deliveryAddressFields) {
                    if (field.value === "") {
                        return // Check if all fields are filled
                    }
                }
                finalizeCheckoutBtn.disabled = false;
                noCourBadge.hidden = true;
                longDeliveryBadge.hidden = true;
                tooLongDeliveryBadge.hidden = true;
                
                const destination = `${deliveryAddressFields[0].value}, ${deliveryAddressFields[2].value}, BC ${deliveryAddressFields[4].value}`
                const response = await checkETA(destination);
                // console.log(response)
                if (response.status === 404) {
                    noCourBadge.hidden = false;
                    finalizeCheckoutBtn.disabled = true;
                    return
                }
                const etas = await response.json()
                if (etas.min_time.value >= 1800 && etas.min_time.value < 2700) {
                    longDeliveryBadge.hidden = false;
                } else if (etas.min_time.value >= 2700) {
                    tooLongDeliveryBadge.hidden = false;
                    finalizeCheckoutBtn.disabled = true;
                }
                if (etas.one_time) {
                    deliveryEta.innerHTML = etas.one_time.text;
                } else {
                    deliveryEta.innerHTML = `${etas.min_time.text} - ${etas.max_time.text}`;
                }
                deliveryEta.parentElement.hidden = false;
            })
        });
        
        // Function: updateCartCount
        // Description: Updates the cart count display based on the number of items in the cart that require payment.
        // - If there are items that require payment, the cart count elements are shown and updated with the number of such items.
        // - If there are no items that require payment, the cart count elements are hidden.
        function updateCartCount() {
            const freeItems = cart.items.reduce((accumulator, value) => value.noPayment ? accumulator + 1 : accumulator, 0)
            const actualLength = cart.items.length - freeItems
            if (actualLength) {
                cartCount.forEach(element => {
                    element.hidden = false;
                })
                cartCount.forEach(element => {
                    element.innerHTML = actualLength;
                })
            } else {
                cartCount.forEach(element => {
                    element.hidden = true;
                })
            }
        }

        let cartUpdateAllowed = true;

        // Function: updateCartItems
        // Description: Updates the cart items displayed in the cart by clearing the current items and re-adding them from the cart object. 
        //              It also handles the removal of items and their children from the cart, updates the cart string, and manages the 
        //              display of item customizations and images.
        // Side Effects: 
        //     - Modifies the innerHTML of the cartItems element.
        //     - Adds event listeners to the remove buttons of each cart item.
        //     - Updates the value of the #cart-string element with the JSON stringified cart object.
        // Dependencies: 
        //     - cart: An object representing the shopping cart.
        //     - cartItems: A DOM element where the cart items are displayed.
        //     - cartItemTemplate: A DOM element template used to clone new cart items.
        //     - cartUpdateAllowed: A boolean flag to control the update process.
        //     - updateCart: A function to update the cart display.
        function updateCartItems() {
            cartItems.innerHTML = "";
            cart.items.forEach((item, index) => {
                const newNode = cartItemTemplate.cloneNode(true);
                newNode.querySelector("img").src = item.fields.image || "https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/No-Image-Placeholder.svg/1665px-No-Image-Placeholder.svg.png"
                newNode.querySelector("h2").innerHTML = item.fields.title
                newNode.querySelector(".price").innerHTML = '$' + item.fields.price
                newNode.querySelector("button").addEventListener("click", e => {
                    if (cartUpdateAllowed) {
                        cartUpdateAllowed = false
                        // console.log(item)
                        item.children?.forEach(child => {
                            const foundChild = cart.items.findIndex(i => i.id == child.id && i.noPayment && i.parent === item.id)
                            // console.log(child)
                            cart.items.splice(foundChild, 1);
                        })
                        cart.removeItem(item, {children:item.children});
                        updateCart()
                        setTimeout(() => {
                            cartUpdateAllowed = true
                        }, 500);
                    }
                })
                if (item.customizationsString) {
                    const customizationNode = newNode.querySelector("small")
                    customizationNode.innerHTML = `With ${item.customizationsString}`
                    customizationNode.hidden = false
                }
                if (!item.noPayment) {
                    newNode.hidden = false;
                }
                cartItems.appendChild(newNode);
            })
            document.querySelector("#cart-string").value = JSON.stringify(cart);
        }

        window.addEventListener("message", e => {
            try {
                if (e.data.transactionSuccessful) {
                    fullResetCart();
                }
            } catch (error) {
                console.log(error)
            }
        })

        function fullResetCart() {
            cart = new Cart();
            updateCart();
        }

        function resetCartPayments() {
            cart.partialPayments = [];
            updateCart();
        }

        // Function: updateCart
        // Description: This asynchronous function updates the cart's state and UI elements based on the current items in the cart.
        // - Updates the cart count and items displayed.
        // - Enables or disables the checkout button based on whether the cart has items.
        // - Toggles the display of the finalize checkout button and submit order button based on the remaining total number in the cart.
        // - Sets the transaction amount input value to the cart's remaining total number.
        // - Updates the inner HTML of elements displaying the cart subtotal.
        // - Saves the cart state to the CartDB.
        async function updateCart() {
            // window.sessionStorage.setItem("cart", cart.stringifySelf);
            updateCartCount();
            updateCartItems();
            if (cart.items.length > 0) {
                checkoutBtn.disabled = false
            } else {
                checkoutBtn.disabled = true
            }
            if (cart.remainingTotalNum) {
                finalizeCheckoutBtn.style.display = "block"
                submitOrderBtn.style.display = "none"
            } else {
                finalizeCheckoutBtn.style.display = "none"
                submitOrderBtn.style.display = "block"
            }
            document.querySelector("#transaction-amount").value = cart.remainingTotalNum;
            cartSubtotal.forEach(element => {
                element.innerHTML = cart.remainingTotal
            })
            // cart.renewLastUpdate();
            CartDB.save(cart);
            // registerResetSync();
        }

        // This script adds event listeners to the finalizeCheckoutBtn and submitOrderBtn buttons. 
        // When either button is clicked, the following actions are performed:

        // 1. If there are partial payments in the cart:
        //     a. Validate all required form fields. If any required field is empty, trigger a form submission to highlight errors and exit.
        //     b. Disable the clicked button, add a loading class, and change its inner HTML to indicate that gift cards are being checked.
        //     c. Fetch the available balance for each gift card in the cart.
        //     d. Check if any gift card's available balance is less than the amount in the cart. If so, remove the card from the cart and store its last four digits.
        //     e. Update the cart.
        //     f. If any gift cards were removed due to insufficient balance, alert the user, re-enable the button, remove the loading class, restore the button's original text, and close any open dialog.
        //     g. If the remaining total in the cart is zero, submit the form, reset the cart, and exit.

        // 2. If there are no partial payments or after handling partial payments, trigger a form submission to handle validation and submission.
        [finalizeCheckoutBtn, submitOrderBtn].forEach(button => {
            button.addEventListener("click", async e => {
                if (cart.partialPayments.length) {
                    for (const element of document.querySelectorAll("[required]")) {
                        if (!element.value) {
                            // Basically do form validation with error highlighting.
                            document.querySelector("#true-submit-button").click()
                            return
                        }
                    }
                    const oldText = button.innerHTML
                    button.disabled = true
                    button.classList.add("loading")
                    button.innerHTML = "<span class='circle'></span><span>{% trans 'Checking your gift cards' %}</span>"
                    const fetchPromises = cart.partialPayments.map(async card => {
                        const response = await fetch(`/gift-cards/card-api/${card.number}`);
                        return response.json();
                    });
                    const results = await Promise.all(fetchPromises);
                    let removedNumbers = []
                    results.forEach(card => {
                        const index = cart.partialPayments.findIndex(element => element.number === card.number && element.amount > parseFloat(card.available_balance))
                        if (index !== -1) {
                            removedNumbers.push(cart.partialPayments[index].number.slice(-4))
                            console.log(index)
                            console.log("Removed:")
                            console.log(cart.partialPayments[index])
                            cart.partialPayments.splice(index, 1);
                        }
                    })
                    updateCart();
                    if (removedNumbers.length) {
                        alert(gettext(`Looks like ${removedNumbers.length === 1 ? "one" : "some"} of your gift cards ${removedNumbers.length === 1 ? "has" : "have"} changed since you redeemed them. Card${removedNumbers.length === 1 ? "" : "s"} ending with ${removedNumbers} ha${removedNumbers.length === 1 ? "s" : "ve"} insufficient balance and ha${removedNumbers.length === 1 ? "s" : "ve"} been removed. Input the number${removedNumbers.length === 1 ? "" : "s"} again to see the updated balance.`))
                        button.disabled = false
                        button.classList.remove("loading")
                        button.innerHTML = oldText
                        document.querySelector("dialog[open]").close()
                        return
                    }
                    if (cart.remainingTotalNum === 0) {
                        finalizeForm.submit()   
                        fullResetCart()
                        return
                    }
                }
                // This is awkward but it solves the form validation as well as submission.
                document.querySelector("#true-submit-button").click()
            })
        })

        async function checkETA(destination) {
            return fetch(`{% url 'eta' %}?destination=${destination}&customer=true`)
        }

        function registerResetSync() {
            if ('serviceWorker' in navigator && 'SyncManager' in window) {
                navigator.serviceWorker.ready
                    .then((registration) => {
                        // console.log('Service Worker is ready:', registration);
                        // Register the sync task
                        registration.sync.register('reset-cart-payments');
                        // console.log('Background sync registered for cart reset.');
                    })
                    .catch((error) => {
                        console.error('Failed to register background sync:', error);
                    });
            } else {
                console.warn('Background Sync is not supported in this browser.');
            }
        }

        // Function: saveCartToIndexedDB

        // Description:
        // This function saves the provided cart data to the IndexedDB database named 'CartDB'. 
        // If the database or the 'cart' object store does not exist, they are created.

        // Parameters:
        // - cart (Object): The cart data to be saved in the IndexedDB.

        // IndexedDB Operations:
        // - Opens the 'CartDB' database with version 1.
        // - If the database upgrade is needed (i.e., the database is being created for the first time or a new version is specified), 
        //   it creates an object store named 'cart' with 'id' as the keyPath.
        // - On successful opening of the database, it starts a readwrite transaction on the 'cart' object store and 
        //   stores the provided cart data with 'currentCart' as the key.
        function saveCartToIndexedDB(cart) {
            const request = indexedDB.open('CartDB', 1); // Ensure the version number is correct (1 in this case)

            request.onupgradeneeded = function (event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('cart')) {
                    db.createObjectStore('cart', { keyPath: 'id' }); // Create the 'cart' object store
                    // console.log('Object store "cart" created.');
                }
            };

            request.onsuccess = function (event) {
                const db = event.target.result;
                const transaction = db.transaction(['cart'], 'readwrite');
                const store = transaction.objectStore('cart');
                store.put({ id: 'currentCart', data: cart });
            };
        }

        // Function: getCartFromIndexedDB

        // Description:
        // This function retrieves the current cart data from an IndexedDB database named 'CartDB'. 
        // It returns a Promise that resolves with the cart data or null if the data is not found or an error occurs.

        // Usage:
        // getCartFromIndexedDB().then(cartData => {
        //     // Use the cart data
        // }).catch(error => {
        //     // Handle any errors
        // });

        // IndexedDB Structure:
        // - Database: CartDB (version 1)
        // - Object Store: cart (keyPath: 'id')

        // Returns:
        // - Promise: Resolves with the cart data or null if not found or an error occurs.

        // Error Handling:
        // - Logs an error message to the console if the database fails to open or if the cart data retrieval fails.
        function getCartFromIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('CartDB', 1); // Ensure the version number is correct (1 in this case)

                request.onupgradeneeded = function (event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('cart')) {
                        db.createObjectStore('cart', { keyPath: 'id' }); // Create the 'cart' object store
                        // console.log('Object store "cart" created.');
                    }
                };

                request.onsuccess = function (event) {
                    const db = event.target.result;
                    const transaction = db.transaction(['cart'], 'readonly');
                    const store = transaction.objectStore('cart');
                    const getRequest = store.get('currentCart');

                    getRequest.onsuccess = function () {
                        resolve(getRequest.result ? getRequest.result.data : null); // Return the cart data or null
                    };

                    getRequest.onerror = function () {
                        console.error('Failed to retrieve cart from IndexedDB');
                        resolve(null); // Resolve with null on error
                    };
                };

                request.onerror = function () {
                    console.error('Failed to open IndexedDB');
                    resolve(null); // Resolve with null if the database fails to open
                };
            });
        }
    </script>
    <dialog id="payment-popup"></dialog>
    <script>const webPaymentWindowURL = '{% url "web-payment-window" %}';</script>
    <script src="{% static 'payments/cardPaymentPopup.js' %}"></script>
</body>
</html>